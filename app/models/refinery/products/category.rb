require 'refinery/categories/finder'

module Refinery
  module Products
    class Category < Refinery::Core::BaseModel
      extend FriendlyId



      translates :title, :slug

      class FriendlyIdOptions
        def self.reserved_words
          %w(index new session login logout users refinery admin images)
        end

        def self.options
          # Docs for friendly_id https://github.com/norman/friendly_id
          friendly_id_options = {
            use: [:reserved],
            reserved_words: self.reserved_words
          }
          if ::Refinery::Pages.scope_slug_by_parent
            friendly_id_options[:use] << :scoped
            friendly_id_options.merge!(scope: :parent)
          end
          friendly_id_options[:use] << :globalize
          friendly_id_options
        end
      end

      # If title changes tell friendly_id to regenerate slug when saving record
      def should_generate_new_friendly_id?
        changes.keys.include?("title")
      end

      acts_as_nested_set :dependent => :destroy

      friendly_id :title, FriendlyIdOptions.options

      belongs_to :photo, :class_name => '::Refinery::Image'

      has_many :categorizations, :dependent => :destroy, :foreign_key => :products_category_id
      has_many :products, :through => :categorizations, :source => :product

      validates :title, :presence => true, :uniqueness => true

      acts_as_indexed :fields => [:title]

      # If title changes tell friendly_id to regenerate slug when
      # saving record
      def should_generate_new_friendly_id?
        title_changed?
      end

      def self.translated
        with_translations(::Globalize.locale)
      end

      def category_count
        categories.live.with_globalize.count
      end

      def translated_to_default_locale?
        persisted? && translations.any?{|t| t.locale == Refinery::I18n.default_frontend_locale}
      end



      class << self
        # Find page by path, checking for scoping rules
        def find_by_path(path)
          Categories::Finder.by_path(path)
        end

        # Helps to resolve the situation where you have a path and an id
        # and if the path is unfriendly then a different finder method is required
        # than find_by_path.
        def find_by_path_or_id(path, id)
          Categories::Finder.by_path_or_id(path, id)
        end

        # Helps to resolve the situation where you have a path and an id
        # and if the path is unfriendly then a different finder method is required
        # than find_by_path.
        #
        # raise ActiveRecord::RecordNotFound if not found.
        def find_by_path_or_id!(path, id)
          category = find_by_path_or_id(path, id)

          raise ActiveRecord::RecordNotFound unless category

          category
        end

        # Finds pages by their title.  This method is necessary because pages
        # are translated which means the title attribute does not exist on the
        # pages table thus requiring us to find the attribute on the translations table
        # and then join to the pages table again to return the associated record.
        def by_title(title)
          Categories::Finder.by_title(title)
        end

        # Finds pages by their slug.  This method is necessary because pages
        # are translated which means the slug attribute does not exist on the
        # pages table thus requiring us to find the attribute on the translations table
        # and then join to the pages table again to return the associated record.
        def by_slug(slug, conditions = {})
          Categories::Finder.by_slug(slug, conditions)
        end

        # Wrap up the logic of finding the pages based on the translations table.
        def with_globalize(conditions = {})
          Categories::Finder.with_globalize(conditions)
        end
      end

      def nested_url
        Globalize.with_locale(slug_locale) do
          self_and_ancestors.includes(:translations).map(&:to_param)
        end
      end

      # Returns an array with all ancestors to_param, allow with its own
      # Ex: with an About page and a Mission underneath,
      # ::Refinery::Page.find('mission').nested_url would return:
      #
      #   ['about', 'mission']
      #
      alias_method :uncached_nested_url, :nested_url

      # Returns the string version of nested_url, i.e., the path that should be
      # generated by the router
      def nested_path
        ['', nested_url].join('/')
      end

      private

        def slug_locale
          return Globalize.locale if translation_for(Globalize.locale).try(:slug).present?

          if translations.empty? || translation_for(Refinery::I18n.default_frontend_locale).present?
            Refinery::I18n.default_frontend_locale
          else
            translations.first.locale
          end
        end
    end
  end
end
